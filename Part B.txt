
1. Problem Statement: Finding the Average
    A. Given a set of numbers, how can we find their average?
    B. Example: Given the numbers [5, 8, 12, 4, 10], calculate the average.
Iterate over the input array "[5, 8, 12, 4, 10]"
Sum each value and count the total number of values
Divide the sum by the total number of values


2. Develop pseudo code to solve the problem statement outlined in Step 1.
    A. Use descriptive variable names and comments to enhance readability and understanding.

Pseudocode: 
input <- [5, 8, 12, 4, 10]
count <- 0
total <- 0
for x in input do
    count <- count + 1
    total <- total + x 
average <- total / count


3. Write a Backus-Naur Form (BNF) grammar to describe the syntax of the problem statement.

<program> ::= <statement_list>
<statement_list> ::= <statement> | <statement> <statement_list>
<statement> ::= <declaration> | <for_loop>
<declaraon> ::= <identifier> "<-" <expression>
<for_loop> ::= "for" <identifier> "in" <identifer> "do" <stmts>
<identifier> ::= <letter> { <letter> }
<letter> ::= "a" | "b" .. "z" | "A" .. "Z"
<expression> ::= <number> | <identifier> | <expression> <operator> <expression> | <list>
<list> ::= "[" <number> { "," <number> } "]"
<operator> ::= "*" | "/" | "-" | "+"
<number> ::= <digit> { <digit> }
<digit> ::= "0" | "1" .. "8" | "9"

4. Construct a parse tree based on the BNF grammar to visualize the syntactic structure of the problem.
See Syntax tree.png

5. Examine the parse tree constructed in Step 4 to determine if the BNF grammar is ambiguous.
    A. Identify any areas where multiple interpretations are possible.
    Because this parse tree contains simple statements and expressions with no more than 1 operator, it isn't ambiguous anywhere. This could change if certain complex logic or expressions were introduced or mixing of if and else statements 
    
    B. Provide examples or scenarios to illustrate potential ambiguities and their implications.
    Grammar can be ambiguous when multiple different parse trees can be drawn from a string and no precedence is defined. 
        For example: 1 + 3 / 2. This can either be interpreted as (1 + 3) / 2 or 1 + (3 / 2)
        Another case is the use of if else without clear separation of conditions and statements
        For example: 
        if x > 0
        if y > 0
        # case 1
        else 
        # case 2

        Its unclear which condition would lead to the code after "else" being executed, and this could be interpreted in multiple ways in a parse tree

6. Rewrite the BNF grammar using Extended Backus-Naur Form (EBNF) to enhance readability and expressiveness.
    - Explain the benefits of using EBNF over traditional BNF, particularly in terms of readability and clarity.
    EBNF extends BNF by adding: 
        [] = optional parts 
        {} = repetition (0 or more times)
        () = grouping of expressions
        | = alternation (choice)
        - use = and ; instead of ::= 
    - Remove any ambiguity present in the BNF grammar through syntax modifications in the EBNF version.
    program = { statement } ;
    statement = declaration | for_loop ;
    declaration = identifier "<--" expression ;
    for_loop = "for": identifier "in" identifier "do" { statement } "end";
    expression = term { operator term }:
    term = number | identifier | list ;
    list = "[" number { "," number } "]" ;
    operator = "+" | "-" | "*" | "/" ;
    identifier = letter { letter | digit } ;
    letter = "A".."Z" | "a".."z"
    digit         = "0".."9" ;
    number        = digit { digit } ;           



7. Use the EBNF grammar to reconstruct a parse tree, demonstrating how the revised syntax resolves any ambiguities present in the original BNF grammar.
program
 └── statement
      └── declaration
           ├── identifier → "average"
           ├── "<-"
           └── expression
                ├── term → identifier("total")
                ├── operator → "/"
                └── term → identifier("count")
    - Analyze and compare the parse trees from Steps 4 and 7 to understand the impact of syntax modifications on the parse tree structure.
      - The syntax modification of the EBNF grammar makes it much easier to see and understand the parse tree structure. 
      - Addtionally, compared to the structure made from using the BNF grammar, this one illustrates the heirarchy and relationship between the components more clearly.
